{% extends "admin_base.html" %}

{% block content %}
<!-- Add Flatpickr CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flatpickr/4.6.13/flatpickr.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/flatpickr/4.6.13/flatpickr.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>


<div class="min-h-screen bg-gray-50 py-8">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    <!-- Header Section -->
    <div class="mb-8">
      <h1 class="text-3xl font-bold text-gray-900">Event Management</h1>
      <div class="mt-4 flex justify-end">
        <button 
          onclick="openNewEventModal()" 
          class="inline-flex items-center px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
        >
          <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
          </svg>
          New Event
        </button>
      </div>
    </div>

    <!-- Events Table -->
    <div class="bg-white rounded-lg shadow overflow-hidden w-full">
      <table class="min-w-full divide-y divide-gray-200" style="width: 100%;">
        <thead class="bg-gray-50">
          <tr>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-1/4">Event Title</th>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-1/6">Date</th>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Races</th>
            <th class="px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider w-32">Actions</th>
          </tr>
        </thead>
        <tbody class="bg-white divide-y divide-gray-200">
          {% if manual_entries %}
            {% for entry in manual_entries %}
            <tr class="hover:bg-gray-50">
              <td class="px-4 py-3">
                <div class="text-sm font-medium text-gray-900">{{ entry.event_title|default('') }}</div>
              </td>
              <td class="px-4 py-3">
                <div class="text-sm text-gray-900">{{ entry.event_date|default('Not set') }}</div>
              </td>
              <td class="px-4 py-3">
                <div class="flex flex-wrap gap-2">
                  {% if entry.races %}
                    {% for race in entry.races %}
                    <div class="text-sm bg-gray-100 rounded px-3 py-1">
                      <span class="font-medium">{{ race.race_title|default('') }}</span>
                      <span class="text-gray-500 ml-2">
                        ({% if race.mode == 1 %}Event{% elif race.mode == 2 %}Finale{% else %}Stige{% endif %})
                      </span>
                    </div>
                    {% endfor %}
                  {% endif %}
                </div>
              </td>
              <td class="px-4 py-3 text-right text-sm font-medium">
                <button 
                  onclick="openEditModal({{ entry.id|default(0) }})" 
                  class="text-blue-600 hover:text-blue-900 mr-3"
                >Edit</button>
                <button 
                  onclick="deleteEvent({{ entry.id|default(0) }})" 
                  class="text-red-600 hover:text-red-900"
                >Delete</button>
              </td>
            </tr>
            {% endfor %}
          {% endif %}
        </tbody>
      </table>
    </div>
  </div>
</div>

<!-- Modal -->
<div id="eventModal" class="fixed inset-0 bg-gray-500 bg-opacity-75 hidden" aria-hidden="true">
  <!-- Modal content here -->
  <div class="fixed inset-0 overflow-y-auto">
    <div class="flex min-h-full items-end justify-center p-4 text-center sm:items-center sm:p-0" style="margin-top: 10%;">
      <div class="relative transform overflow-hidden rounded-lg bg-white text-left shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-3xl" style="width: 40%;">
        <!-- Modal Header -->
        <div class="bg-white px-4 pt-5 pb-4 sm:p-6 sm:pb-4">
          <div class="flex items-center justify-between mb-4">
            <h3 class="text-lg font-medium leading-6 text-gray-900" id="modalTitle">New Event</h3>
            <button onclick="closeModal()" class="text-gray-400 hover:text-gray-500">
              <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
          
          <!-- Event Form -->
          <form id="eventForm" class="space-y-6">
            <input type="hidden" id="event_id" name="event_id">
            <input type="hidden" id="is_edit" name="is_edit">
            
            <!-- Event Title -->
            <div>
              <label for="event_title" class="block text-sm font-medium text-gray-700">Event Title</label>
              <input type="text" id="event_title" name="event_title" 
                     class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
            </div>

            <!-- Event Date -->
            <div>
              <label for="event_date" class="block text-sm font-medium text-gray-700">Event Date</label>
              <div class="mt-1 relative">
                <input type="text" id="event_date" name="event_date" 
                       class="block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 pl-3 pr-10 py-2"
                       placeholder="Select date">
                <button type="button" 
                        class="absolute inset-y-0 right-0 px-3 flex items-center cursor-pointer"
                        onclick="toggleDatePicker()">
                  <svg class="h-5 w-5 text-gray-400 hover:text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                  </svg>
                </button>
              </div>
            </div>

            <!-- Races Section -->
            <div class="space-y-4">
              <div class="flex items-center justify-between">
                <h4 class="text-lg font-medium text-gray-900">Races</h4>
                <button type="button" onclick="addNewRace()" 
                        class="inline-flex items-center px-3 py-1.5 text-sm bg-green-600 text-white rounded-md hover:bg-green-700">
                  <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
                  </svg>
                  Add Race
                </button>
              </div>
              
              <div id="races_container" class="space-y-4">
                <!-- Races will be added here dynamically -->
              </div>
            </div>
          </form>
        </div>

        <!-- Modal Footer -->
        <div class="bg-gray-50 px-4 py-3 sm:flex sm:flex-row-reverse sm:px-6">
          <button type="button" onclick="saveEvent()" 
                  class="inline-flex w-full justify-center rounded-md border border-transparent bg-blue-600 px-4 py-2 text-base font-medium text-white shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 sm:ml-3 sm:w-auto sm:text-sm">
            Save Changes
          </button>
          <button type="button" onclick="closeModal()" 
                  class="mt-3 inline-flex w-full justify-center rounded-md border border-gray-300 bg-white px-4 py-2 text-base font-medium text-gray-700 shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 sm:mt-0 sm:ml-3 sm:w-auto sm:text-sm">
            Cancel
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
let eventsData = {};


{% if manual_entries %}
  {% for entry in manual_entries %}
    eventsData[{{ entry.id|default(0) }}] = {
      id: {{ entry.id|default(0) }},
      event_title: {{ entry.event_title|default('')|tojson }},
      event_date: {{ entry.event_date|default('')|tojson }},
      races: {{ entry.races|default([])|tojson }}
    };
  {% endfor %}
{% endif %}

// Initialize date picker
let datePicker = null;

function initializeDatePicker() {
  console.log('Initializing date picker...');
  if (datePicker) {
    datePicker.destroy();
  }
  
  const dateElement = document.getElementById('event_date');

  if (dateElement) {
    console.log('Found date element, creating Flatpickr instance...');
    datePicker = flatpickr(dateElement, {
      dateFormat: "Y-m-d",
      altInput: true,
      altFormat: "F j, Y",
      disableMobile: true,
      allowInput: true,
      clickOpens: true,
      onOpen: function() {
        console.log('Date picker opened');
      }
    });
    console.log('Flatpickr initialized:', datePicker);
  } else {
    console.log('Date element not found');
  }
}

function toggleDatePicker() {
  console.log('Toggle date picker clicked');
  if (datePicker) {
    datePicker.toggle();
  } else {
    console.log('Date picker not initialized, initializing now...');
    initializeDatePicker();
    datePicker.toggle();
  }
}

function deleteEvent(eventId) {
  if (confirm("Are you sure you want to delete this event?")) {
    fetch(window.location.href, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify({ action: 'delete', id: eventId })
    })
      .then(response => {
        if (!response.ok) {
          return response.json().then(err => {
            throw new Error(err.message || 'Failed to delete event');
          });
        }
        return response.json();
      })
      .then(data => {
        if (data.success) {
          window.location.reload();
        } else {
          alert(data.message || "An error occurred while deleting the event.");
        }
      })
      .catch(error => {
        console.error("Error deleting event:", error);
        alert("An error occurred while deleting the event.");
      });
  }
}


// Initialize when opening modals
function openNewEventModal() {
  document.getElementById('modalTitle').textContent = 'New Event';
  document.getElementById('event_id').value = '';
  document.getElementById('is_edit').value = 'false';
  document.getElementById('event_title').value = '';
  document.getElementById('event_date').value = '';
  document.getElementById('races_container').innerHTML = '';
  addNewRace(); // Add one empty race by default
  document.getElementById('eventModal').classList.remove('hidden');
  initializeDatePicker(); // Initialize date picker after modal is shown
}

function openNewEventModal() {
  document.getElementById('modalTitle').textContent = 'New Event';
  document.getElementById('event_id').value = '';
  document.getElementById('is_edit').value = 'false';
  document.getElementById('event_title').value = '';
  document.getElementById('event_date').value = '';
  document.getElementById('races_container').innerHTML = '';
  addNewRace(); // Add one empty race by default
  document.getElementById('eventModal').classList.remove('hidden');
  initializeDatePicker(); // Initialize date picker after modal is shown
}

function openEditModal(eventId) {
  const event = eventsData[eventId] || {};
  document.getElementById('modalTitle').textContent = 'Edit Event';
  document.getElementById('event_id').value = eventId;
  document.getElementById('is_edit').value = 'true';
  document.getElementById('event_title').value = event.event_title || '';
  document.getElementById('event_date').value = event.event_date || '';

  const racesContainer = document.getElementById('races_container');
  racesContainer.innerHTML = '';

  if (event.races && Array.isArray(event.races)) {
    event.races.forEach(race => {
      addNewRace(race);
    });
  } else {
    addNewRace(); // Add empty race if no races exist
  }

  // Attach autocomplete to all pre-populated driver inputs
  attachAutocompleteToAllDriverInputs();

  document.getElementById('eventModal').classList.remove('hidden');
}

function closeModal() {
  document.getElementById('eventModal').classList.add('hidden');
}


async function calculateSHA256(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(e) {
            const wordArray = CryptoJS.lib.WordArray.create(e.target.result);
            const hash = CryptoJS.SHA256(wordArray).toString();
            resolve(hash);
        };
        reader.onerror = function(e) {
            reject(new Error('Error reading file'));
        };
        reader.readAsArrayBuffer(file);
    });
}


let pdfStorage = {};
let pdfUploadTracker = new Map(); // Add this to track uploads

async function handlePdfUpload(input, raceId) {
    const file = input.files[0];
    if (file) {
        const nameDisplay = document.getElementById(`${raceId}-pdf-name`);
        if (!nameDisplay) {
          console.error(`[PDF UPLOAD ERROR] Could not find name display element for race ${raceId}`);
          return;
        }
        nameDisplay.textContent = "Uploading...";
        console.log(`[PDF UPLOAD START] Starting upload for race ${raceId} with file ${file.name}`);


        try {
            // Create a new FileReader instance for each upload
            const fileReader = new FileReader();
            const hash = await calculateSHA256(file);
            
            // Log the initial file details
            console.log(`[PDF UPLOAD START] Race: ${raceId}`, {
                filename: file.name,
                size: file.size,
                type: file.type,
                hash: hash
            });

            // Create a new Promise to handle the file reading
            const fileContent = await new Promise((resolve, reject) => {
                fileReader.onload = (e) => resolve(e.target.result);
                fileReader.onerror = (e) => reject(e);
                fileReader.readAsDataURL(file);
            });

            // Store file info with a deep clone to prevent reference sharing
            const content = fileContent.split(',')[1];
            pdfStorage[raceId] = {
                filename: file.name,
                content: content,
                hash: hash,
                timestamp: Date.now()
            };

            // Track this upload
            pdfUploadTracker.set(raceId, {
                hash: hash,
                filename: file.name,
                uploadTime: new Date().toISOString()
            });

            // Log the storage state after update
            console.log(`[PDF STORAGE UPDATE] Race: ${raceId}`, {
                storedHash: pdfStorage[raceId].hash,
                trackedHash: pdfUploadTracker.get(raceId).hash,
                filename: file.name
            });

            nameDisplay.textContent = `${file.name} (Hash: ${hash.substring(0, 8)}...)`;
            nameDisplay.style.color = 'green';

            // Remove existing PDF link if present
            const existingLink = input.parentElement.parentElement.querySelector('a.link');
            if (existingLink) {
                existingLink.remove();
            }

        } catch (error) {
            console.error(`[PDF UPLOAD ERROR] Race: ${raceId}`, error);
            nameDisplay.textContent = "Upload failed: " + error.message;
            nameDisplay.style.color = 'red';
            delete pdfStorage[raceId];
            pdfUploadTracker.delete(raceId);
        }
    }
}

function addNewRace(raceData = null) {
    // Generate a NEW unique ID for each race
    const raceId = 'race-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    console.log(`[NEW RACE] Created with ID: ${raceId}`);
    
    const racesContainer = document.getElementById('races_container');
  
    if (raceData && raceData.pdf_filename) {
        upload_data = `
            <a href="/static/pdfs/manual_entries/${raceData.pdf_filename}" target="_blank" class="link">${raceData.pdf_filename}</a>
            <div class="flex items-center space-x-2">
                <input type="file"
                        accept="application/pdf" 
                        onchange="handlePdfUpload(this, '${raceId}')"
                        class="flex-1 text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-medium file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                <span id="${raceId}-pdf-name" class="text-sm text-gray-500"></span>
            </div>
        `;
    } else {
        upload_data = `
            <div class="flex items-center space-x-2">
                <input type="file"
                        accept="application/pdf" 
                        onchange="handlePdfUpload(this, '${raceId}')"
                        class="flex-1 text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-medium file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                <span id="${raceId}-pdf-name" class="text-sm text-gray-500"></span>
            </div>
        `;
    }

  const raceHtml = `
    <div id="${raceId}" class="bg-white rounded-lg border border-gray-200 p-4">
      <div class="flex items-center justify-between mb-4">
        <div class="flex-1 mr-4">
          <input type="text" name="race_title" placeholder="Race Title" 
                 value="${raceData ? raceData.race_title || '' : ''}"
                 class="w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
        </div>
        <select name="mode" class="rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
          <option value="1" ${raceData && raceData.mode === 1 ? 'selected' : ''}>Event</option>
          <option value="2" ${raceData && raceData.mode === 2 ? 'selected' : ''}>Finale</option>
          <option value="3" ${raceData && raceData.mode === 3 ? 'selected' : ''}>Stige</option>
        </select>
        <button type="button" onclick="removeRace('${raceId}')" 
                class="ml-4 text-red-600 hover:text-red-700">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>
      
      <div class="mt-4 border-t border-gray-200 pt-4">
        <label class="block text-sm font-medium text-gray-700 mb-2">Race PDF</label>
        
      <!-- PDF Upload Section -->
      ${upload_data}
      </div>

      <!-- Drivers Section -->
      <div class="mt-4">
        <div class="flex items-center justify-between mb-2">
          <h5 class="text-sm font-medium text-gray-700">Drivers</h5>
          <button type="button" onclick="addDriver('${raceId}')"
                  class="text-sm text-blue-600 hover:text-blue-700">
            Add Driver
          </button>
        </div>
        <div class="drivers-list space-y-2">
          ${raceData && raceData.driver_places ? 
            raceData.driver_places.map((dp, index) => `
              <div class="flex items-center space-x-2">
                <span class="text-sm text-gray-500 w-8">#${index + 1}</span>
                <input type="text" name="driver" value="${dp.driver || ''}"
                       class="flex-1 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                <button type="button" onclick="removeDriver(this)"
                        class="text-red-600 hover:text-red-700">
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                  </svg>
                </button>
              </div>
            `).join('') : ''
          }
        </div>
      </div>
    </div>
  `;
  
  racesContainer.insertAdjacentHTML('beforeend', raceHtml);
}

function removeRace(raceId) {
  document.getElementById(raceId).remove();
}

// Move this to the top of your script section
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
      const cookie = cookies[i].trim();
      if (cookie.substring(0, name.length + 1) === (name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}

function attachAutocompleteToAllDriverInputs() {
  document.querySelectorAll('#races_container input[name="driver"]').forEach(input => {
    if (!input.classList.contains('autocomplete-attached')) {
      initAutocomplete(input);
      input.classList.add('autocomplete-attached');
    }
  });
}

function addDriver(raceId) {
  const raceElement = document.getElementById(raceId);
  const driversList = raceElement.querySelector('.drivers-list');
  const position = driversList.children.length + 1;

  const driverHtml = `
    <div class="flex items-center space-x-2">
      <span class="text-sm text-gray-500 w-8">#${position}</span>
      <input type="text" name="driver" 
             class="flex-1 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
      <button type="button" onclick="removeDriver(this)"
              class="text-red-600 hover:text-red-700">
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
        </svg>
      </button>
    </div>
  `;
  driversList.insertAdjacentHTML('beforeend', driverHtml);
  
  // Attach autocomplete to the new driver input
  const newInput = driversList.lastElementChild.querySelector('input[name="driver"]');
  initAutocomplete(newInput);
}

function removeDriver(button) {
  const driverElement = button.closest('.flex');
  const driversList = driverElement.parentElement;
  driverElement.remove();
  
  // Update positions
  Array.from(driversList.children).forEach((div, index) => {
    div.querySelector('span').textContent = `#${index + 1}`;
  });
}

function saveEvent() {
    const formData = {
        id: document.getElementById('event_id').value,
        action: document.getElementById('event_id').value ? 'edit' : 'create',
        event_title: document.getElementById('event_title').value,
        event_date: document.getElementById('event_date').value,
        races: []
    };

    // Log the state before processing
    console.log('[SAVE START] PDF Storage State:', {...pdfStorage});
    console.log('[SAVE START] Upload Tracker State:', Object.fromEntries(pdfUploadTracker));

    document.querySelectorAll('#races_container > div').forEach(raceDiv => {
        const raceId = raceDiv.id;
        const race = {
            race_title: raceDiv.querySelector('[name="race_title"]').value,
            mode: parseInt(raceDiv.querySelector('[name="mode"]').value),
            driver_places: []
        };

        console.log(`[PROCESSING RACE] ${raceId}`, {
            hasStoredPDF: !!pdfStorage[raceId],
            trackedUpload: pdfUploadTracker.get(raceId)
        });

        if (pdfStorage[raceId]) {
            // Create a deep copy of the PDF data
            race.pdf = JSON.parse(JSON.stringify(pdfStorage[raceId]));
            console.log(`[ADDING PDF] Race: ${raceId}`, {
                filename: race.pdf.filename,
                hash: race.pdf.hash
            });
        } else if (raceDiv.querySelector('a.link')) {
            race.pdf_filename = raceDiv.querySelector('a.link').textContent;
            console.log(`[EXISTING PDF] Race: ${raceId}`, {
                filename: race.pdf_filename
            });
        }

        raceDiv.querySelectorAll('.drivers-list > div').forEach((driverDiv, index) => {
            race.driver_places.push({
                position: index + 1,
                driver: driverDiv.querySelector('[name="driver"]').value
            });
        });

        formData.races.push(race);
    });

    // Final verification before sending
    formData.races.forEach(race => {
        if (race.pdf) {
            console.log(`[FINAL VERIFICATION] Race: ${race.race_title}`, {
                hash: race.pdf.hash,
                filename: race.pdf.filename
            });
        }
    });

    // Send to server with the same fetch logic as before
    fetch(window.location.href, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify(formData)
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => {
                throw new Error(err.message || 'Server error occurred');
            });
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            // Clear storages
            pdfStorage = {};
            pdfUploadTracker.clear();
            window.location.reload();
        } else {
            throw new Error(data.message || 'Unknown error occurred');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert(error.message || 'Error saving event. Please try again.');
    });
}

function initAutocomplete(inputElement) {
  // Create a container for suggestions and append it to document.body
  const dropdown = document.createElement('div');
  dropdown.classList.add('autocomplete-dropdown');
  
  // Basic styling for the dropdown
  Object.assign(dropdown.style, {
    position: 'absolute',
    border: '1px solid #ccc',
    backgroundColor: '#fff',
    zIndex: 10000, // High z-index to appear on top
    maxHeight: '150px',
    overflowY: 'auto',
    display: 'none'
  });
  document.body.appendChild(dropdown);

  // Function to update the dropdown's position based on the input's position
  function updateDropdownPosition() {
    const rect = inputElement.getBoundingClientRect();
    dropdown.style.width = rect.width + 'px';
    dropdown.style.left = rect.left + window.pageXOffset + 'px';
    dropdown.style.top = rect.bottom + window.pageYOffset + 'px';
  }

  let debounceTimeout;
  let selectedIndex = -1;

  inputElement.addEventListener('input', function () {
    const searchTerm = inputElement.value;
    if (debounceTimeout) clearTimeout(debounceTimeout);
    debounceTimeout = setTimeout(() => {
      if (searchTerm.length < 2) {
        dropdown.style.display = 'none';
        return;
      }
      // Update dropdown position on input
      updateDropdownPosition();

      // Call your API endpoint:
      fetch(`/api/search-drivers?term=${encodeURIComponent(searchTerm)}`)
        .then(response => response.json())
        .then(data => {
          if (data.length > 0) {
            populateDropdown(data);
          } else {
            dropdown.innerHTML = '<div style="padding: 5px;">No results found</div>';
            dropdown.style.display = 'block';
          }
        })
        .catch(err => {
          console.error('Error searching drivers:', err);
        });
    }, 300);
  });

  inputElement.addEventListener('keydown', function (e) {
    const items = dropdown.querySelectorAll('.autocomplete-item');
    if (items.length === 0) return;
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      selectedIndex = (selectedIndex + 1) % items.length;
      updateActiveItem();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      selectedIndex = (selectedIndex - 1 + items.length) % items.length;
      updateActiveItem();
    } else if (e.key === 'Enter') {
      if (selectedIndex >= 0 && items[selectedIndex]) {
        e.preventDefault();
        items[selectedIndex].click();
      }
    }
  });

  function updateActiveItem() {
    const items = dropdown.querySelectorAll('.autocomplete-item');
    items.forEach((item, index) => {
      item.style.backgroundColor = index === selectedIndex ? '#f0f0f0' : '#fff';
    });
  }

  function populateDropdown(data) {
    dropdown.innerHTML = '';
    selectedIndex = -1;
    data.forEach((item) => {
      // Each item is a string from your API
      const div = document.createElement('div');
      div.classList.add('autocomplete-item');
      div.style.padding = '5px';
      div.style.cursor = 'pointer';
      div.textContent = item;
      div.addEventListener('click', () => {
        inputElement.value = item;
        dropdown.style.display = 'none';
      });
      dropdown.appendChild(div);
    });
    dropdown.style.display = 'block';
  }

  // Hide the dropdown if clicking outside of the input or dropdown
  document.addEventListener('click', function (e) {
    if (e.target !== inputElement && !dropdown.contains(e.target)) {
      dropdown.style.display = 'none';
    }
  });

  // Optionally update position on window resize or scroll
  window.addEventListener('resize', updateDropdownPosition);
  window.addEventListener('scroll', updateDropdownPosition);
}



</script>
{% endblock %}